<!DOCTYPE html>
<html lang="ja">
<head>
    <link rel="manifest" href="manifest.json">
    <meta charset="UTF-8">
    <title>ã‚ªã‚»ãƒ­ã‚²ãƒ¼ãƒ  (ã‚¬ã‚¤ãƒ‰åˆ‡ã‚Šæ›¿ãˆãƒ»Undoæ©Ÿèƒ½ä»˜ã)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
        /* ======================================= */
        /* CSSã‚»ã‚¯ã‚·ãƒ§ãƒ³ */
        /* ======================================= */
        body {
            text-align: center;
            font-family: sans-serif;
            background-color: #f0f0f0;
            padding: 10px;
            margin: 0;
        }

        #game-container {
            width: 95%; 
            max-width: 600px;
            min-width: 300px; 
            margin: 10px auto;
            background-color: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            box-sizing: border-box;
        }

        h1 {
            color: #333;
            font-size: 24px;
        }

        #game-info {
            margin-bottom: 15px;
            font-size: 16px;
        }
        
        #controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        
        /* ğŸ’¡ã‚¬ã‚¤ãƒ‰ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #guide-controls {
            margin: 15px 0;
            font-size: 14px;
            padding: 5px;
            border: 1px dashed #ccc;
            border-radius: 5px;
        }
        #guide-controls label {
            margin: 0 8px;
            font-weight: bold;
        }

        #board-wrapper {
            width: 100%;
            padding-bottom: 100%;
            height: 0; 
            position: relative;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            height: 100%;
            border: 4px solid #000;
            background-color: #008000; 
            box-sizing: border-box;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        .cell {
            border: 1px solid #005000;
            display: flex; 
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: background-color 0.1s;
            height: 100%;
            box-sizing: border-box;
        }
        
        .cell:hover:not(.stone) {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .stone {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            transition: transform 0.3s, background-color 0.3s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            transform-style: preserve-3d;
            transform: rotateY(0deg); 
            backface-visibility: hidden;
        }

        .black {
            background-color: black;
        }

        .white {
            background-color: white;
            border: 1px solid #ccc;
        }
        
        .flipping-to-white {
            transform: rotateY(180deg);
            background-color: white;
        }
        .flipping-to-black {
            transform: rotateY(0deg);
            background-color: black;
        }
        
        .cell.valid-move {
            background-color: rgba(255, 255, 0, 0.3) !important; 
        }

        #reset-button, #undo-button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #3f51b5;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.2s;
        }
        #reset-button:hover, #undo-button:hover:not(:disabled) {
            background-color: #303f9f;
        }
        #undo-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        @media (min-width: 600px) {
            h1 { font-size: 28px; }
            #game-info { font-size: 18px; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>ã‚ªã‚»ãƒ­ã‚²ãƒ¼ãƒ  (Reversi)</h1>
        
        <div id="game-info">
            <p>ç¾åœ¨ã®ã‚¿ãƒ¼ãƒ³: <span id="current-player">é»’ (Black)</span></p>
            <p>ã‚¹ã‚³ã‚¢: <span id="score-black">2</span> (é»’) - <span id="score-white">2</span> (ç™½)</p>
        </div>
        
        <div id="guide-controls">
            <label>
                <input type="checkbox" id="guide-black" data-player="1" checked> 
                é»’ã®ã‚¬ã‚¤ãƒ‰
            </label>
            <label>
                <input type="checkbox" id="guide-white" data-player="2" checked> 
                ç™½ã®ã‚¬ã‚¤ãƒ‰
            </label>
        </div>
        
        <div id="board-wrapper">
            <div id="board">
            </div>
        </div>

        <div id="controls">
            <button id="undo-button" disabled>ä¸€æ‰‹æˆ»ã™ (Undo)</button>
            <button id="reset-button">ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
    </div>

    <script>
        /* ======================================= */
        /* JavaScriptã‚»ã‚¯ã‚·ãƒ§ãƒ³: ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ */
        /* ======================================= */

        const boardElement = document.getElementById('board');
        const currentPlayerElement = document.getElementById('current-player');
        const scoreBlackElement = document.getElementById('score-black');
        const scoreWhiteElement = document.getElementById('score-white');
        const resetButton = document.getElementById('reset-button');
        const guideControls = document.getElementById('guide-controls');
        const undoButton = document.getElementById('undo-button'); // ğŸ’¡ã€è¿½åŠ ã€‘

        const EMPTY = 0;
        const BLACK = 1;
        const WHITE = 2;
        const playerNames = { 1: 'é»’ (Black)', 2: 'ç™½ (White)' };

        let board = Array(8).fill(0).map(() => Array(8).fill(EMPTY));
        let currentPlayer = BLACK;
        let gameActive = true; // ã‚²ãƒ¼ãƒ ãŒç¶™ç¶šä¸­ã‹ã©ã†ã‹
        
        let guideSettings = { 
            [BLACK]: true,
            [WHITE]: true 
        };
        
        // ğŸ’¡ã€è¿½åŠ ã€‘å±¥æ­´ç®¡ç†ç”¨ã®ã‚¹ã‚¿ãƒƒã‚¯
        let history = []; 
        const MAX_HISTORY_SIZE = 20; 

        const directions = [
            [-1, 0], [1, 0], [0, -1], [0, 1],
            [-1, -1], [-1, 1], [1, -1], [1, 1]
        ];

        // -------------------
        // 1. åˆæœŸåŒ–å‡¦ç†
        // -------------------

        function initializeGame() {
            board = Array(8).fill(0).map(() => Array(8).fill(EMPTY));
            board[3][3] = WHITE;
            board[3][4] = BLACK;
            board[4][3] = BLACK;
            board[4][4] = WHITE;
            currentPlayer = BLACK;
            gameActive = true; // ã‚²ãƒ¼ãƒ ã‚’å†é–‹
            
            // ğŸ’¡ã€è¿½åŠ ã€‘å±¥æ­´ã‚’ã‚¯ãƒªã‚¢
            history = []; 

            drawBoard();
            updateGameInfo();
            updateUndoButtonState();
        }
        
        // -------------------
        // 2. å±¥æ­´ç®¡ç†æ©Ÿèƒ½
        // -------------------

        /**
         * ç¾åœ¨ã®ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’å±¥æ­´ã«ä¿å­˜ã™ã‚‹
         */
        function recordState() {
            // ç›¤é¢é…åˆ—ã‚’ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼
            const boardCopy = board.map(row => [...row]); 

            if (history.length >= MAX_HISTORY_SIZE) {
                history.shift(); 
            }

            history.push({ 
                board: boardCopy, 
                currentPlayer: currentPlayer,
                // gameActiveã®çŠ¶æ…‹ã‚‚è¨˜éŒ²ï¼ˆã‚²ãƒ¼ãƒ çµ‚äº†ç›´å‰ãªã©ã®çŠ¶æ…‹ã‚’æˆ»ã™ãŸã‚ï¼‰
                gameActive: gameActive 
            });
            
            updateUndoButtonState();
        }
        
        /**
         * ä¸€æ‰‹å‰ã®çŠ¶æ…‹ã«æˆ»ã™
         */
        function undoMove() {
            if (history.length === 0) {
                return;
            }

            const previousState = history.pop();
            
            // ç›¤é¢ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å¾©å…ƒ
            board = previousState.board.map(row => [...row]);
            currentPlayer = previousState.currentPlayer;
            gameActive = previousState.gameActive; // çŠ¶æ…‹ã‚‚å¾©å…ƒ

            // ç›¤é¢ã‚’å†æç”»
            drawBoard();
            // ã‚²ãƒ¼ãƒ æƒ…å ±ã‚’æ›´æ–°ï¼ˆã‚¹ã‚³ã‚¢å†è¨ˆç®—ã€ã‚¿ãƒ¼ãƒ³è¡¨ç¤ºã€ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼‰
            updateGameInfo(); 
            
            updateUndoButtonState();
        }

        /**
         * Undoãƒœã‚¿ãƒ³ã®æœ‰åŠ¹/ç„¡åŠ¹ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹
         */
        function updateUndoButtonState() {
            // å±¥æ­´ãŒã‚ã‚‹å ´åˆã«ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹ã«ã™ã‚‹
            undoButton.disabled = history.length === 0;
        }

        // -------------------
        // 3. æç”»ãƒ»æ›´æ–°å‡¦ç†
        // -------------------

        function drawBoard() {
            boardElement.innerHTML = '';
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.y = y;
                    cell.dataset.x = x;

                    if (board[y][x] !== EMPTY) {
                        const stone = document.createElement('div');
                        stone.classList.add('stone');
                        stone.classList.add(board[y][x] === BLACK ? 'black' : 'white');
                        cell.appendChild(stone);
                    }

                    cell.addEventListener('click', handleCellClick);
                    boardElement.appendChild(cell);
                }
            }
        }

        function updateGameInfo() {
            let blackCount = 0;
            let whiteCount = 0;
            let emptyCount = 0;

            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    if (board[y][x] === BLACK) blackCount++;
                    else if (board[y][x] === WHITE) whiteCount++;
                    else emptyCount++;
                }
            }

            scoreBlackElement.textContent = blackCount;
            scoreWhiteElement.textContent = whiteCount;
            currentPlayerElement.textContent = playerNames[currentPlayer];
            
            checkGameStatus(emptyCount, blackCount, whiteCount);
        }
        
        // ... (getFlippableStones, flipStones, hasValidMove é–¢æ•°ã¯ãã®ã¾ã¾)
        // [å…ƒã®ã‚³ãƒ¼ãƒ‰ã® getFlippableStones, flipStones, hasValidMove é–¢æ•°ã‚’ã“ã“ã«å«ã‚ã‚‹]

        function getFlippableStones(startY, startX, player) {
            const opponent = player === BLACK ? WHITE : BLACK;
            const flippable = [];
            if (board[startY][startX] !== EMPTY) return [];
            for (const [dy, dx] of directions) {
                const stonesInDirection = [];
                let y = startY + dy;
                let x = startX + dx;
                while (y >= 0 && y < 8 && x >= 0 && x < 8 && board[y][x] === opponent) {
                    stonesInDirection.push({ y, x });
                    y += dy;
                    x += dx;
                }
                if (stonesInDirection.length > 0 && y >= 0 && y < 8 && x >= 0 && x < 8 && board[y][x] === player) {
                    flippable.push(...stonesInDirection);
                }
            }
            return flippable;
        }
        
        function flipStones(stones, player) {
            const colorClass = player === BLACK ? 'black' : 'white';
            const flipClass = player === BLACK ? 'flipping-to-black' : 'flipping-to-white';
            for (const { y, x } of stones) {
                board[y][x] = player;
                const cell = boardElement.querySelector(`[data-y="${y}"][data-x="${x}"]`);
                const stoneElement = cell.querySelector('.stone');
                if (stoneElement) {
                    stoneElement.classList.remove('black', 'white', 'flipping-to-black', 'flipping-to-white');
                    stoneElement.classList.add(flipClass);
                    setTimeout(() => {
                        stoneElement.classList.remove('flipping-to-black', 'flipping-to-white');
                        stoneElement.classList.add(colorClass);
                    }, 300);
                }
            }
        }
        
        function hasValidMove(player) {
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    if (board[y][x] === EMPTY && getFlippableStones(y, x, player).length > 0) {
                        return true;
                    }
                }
            }
            return false;
        }


        function highlightValidMoves() {
            // å‰ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ã™ã¹ã¦ã‚¯ãƒªã‚¢
            document.querySelectorAll('.cell.valid-move').forEach(cell => {
                cell.classList.remove('valid-move');
                cell.style.backgroundColor = ''; 
            });
            
            // ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¬ã‚¤ãƒ‰ãŒONã®å ´åˆã®ã¿å‡¦ç†ã‚’å®Ÿè¡Œ
            if (gameActive && guideSettings[currentPlayer]) { 
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        if (board[y][x] === EMPTY && getFlippableStones(y, x, currentPlayer).length > 0) {
                            const cell = boardElement.querySelector(`[data-y="${y}"][data-x="${x}"]`);
                            cell.classList.add('valid-move');
                            cell.style.backgroundColor = 'rgba(255, 255, 0, 0.3)'; 
                        }
                    }
                }
            }
        }
        
        function checkGameStatus(emptyCount, blackCount, whiteCount) {
            const blackCanMove = hasValidMove(BLACK);
            const whiteCanMove = hasValidMove(WHITE);

            if (emptyCount === 0 || (!blackCanMove && !whiteCanMove)) {
                gameActive = false; // ã‚²ãƒ¼ãƒ çµ‚äº†
                let message;
                if (blackCount > whiteCount) {
                    message = `ã‚²ãƒ¼ãƒ çµ‚äº†ï¼é»’ã®å‹åˆ©ï¼ (${blackCount} vs ${whiteCount})`;
                } else if (whiteCount > blackCount) {
                    message = `ã‚²ãƒ¼ãƒ çµ‚äº†ï¼ç™½ã®å‹åˆ©ï¼ (${blackCount} vs ${whiteCount})`;
                } else {
                    message = `ã‚²ãƒ¼ãƒ çµ‚äº†ï¼å¼•ãåˆ†ã‘ã§ã™ï¼ (${blackCount} vs ${whiteCount})`;
                }
                currentPlayerElement.innerHTML = `<span style="color:red; font-weight:bold;">${message}</span>`;
            } else if (!hasValidMove(currentPlayer)) {
                // ãƒ‘ã‚¹å‡¦ç†
                alert(`${playerNames[currentPlayer]}ã¯ç½®ã‘ã‚‹å ´æ‰€ãŒãªã„ãŸã‚ãƒ‘ã‚¹ã§ã™ã€‚`);
                currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
                currentPlayerElement.textContent = playerNames[currentPlayer];
                highlightValidMoves();
            } else {
                // ç¶šè¡Œ
                highlightValidMoves();
            }
            
            updateUndoButtonState();
        }


        // -------------------
        // 4. ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
        // -------------------

        function handleCellClick(event) {
            if (!gameActive) return; // ã‚²ãƒ¼ãƒ çµ‚äº†æ™‚ã¯æ“ä½œä¸å¯

            const y = parseInt(event.currentTarget.dataset.y);
            const x = parseInt(event.currentTarget.dataset.x);
            
            if (board[y][x] !== EMPTY) {
                return;
            }

            const flippableStones = getFlippableStones(y, x, currentPlayer);

            if (flippableStones.length === 0) {
                return;
            }

            // ğŸ’¡ã€æŒ¿å…¥ã€‘é§’ã‚’ç½®ãå‰ã«çŠ¶æ…‹ã‚’è¨˜éŒ²
            recordState(); 

            // 1. çŸ³ã‚’ç½®ã
            board[y][x] = currentPlayer;
            
            // 2. ç›¤é¢ã«çŸ³ã®DOMè¦ç´ ã‚’è¿½åŠ 
            const cell = event.currentTarget;
            cell.classList.remove('valid-move');
            cell.style.backgroundColor = ''; 
            
            const stone = document.createElement('div');
            stone.classList.add('stone');
            stone.classList.add(currentPlayer === BLACK ? 'black' : 'white');
            cell.appendChild(stone);

            // 3. çŸ³ã‚’ã²ã£ãã‚Šè¿”ã™
            flipStones(flippableStones, currentPlayer);

            // 4. ã‚¿ãƒ¼ãƒ³äº¤ä»£
            currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;

            // 5. ã‚²ãƒ¼ãƒ æƒ…å ±ã‚’æ›´æ–° (ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¾Œã«æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’è¡Œã†)
            setTimeout(updateGameInfo, 350); 
        }
        
        function handleGuideToggle(event) {
            if (event.target.type === 'checkbox') {
                const player = parseInt(event.target.dataset.player);
                guideSettings[player] = event.target.checked;
                
                // ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¨­å®šãŒå¤‰ã‚ã£ãŸå ´åˆã¯ã€ã™ãã«ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’æ›´æ–°
                if (player === currentPlayer) {
                    highlightValidMoves();
                }
            }
        }

        // PWA: Service Workerã®ç™»éŒ²
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            navigator.serviceWorker.register('/service-worker.js')
              .then((registration) => {
                console.log('Service Worker registration successful with scope: ', registration.scope);
              }, (err) => {
                console.log('Service Worker registration failed: ', err);
              });
          });
        }

        resetButton.addEventListener('click', initializeGame);
        guideControls.addEventListener('change', handleGuideToggle);
        undoButton.addEventListener('click', undoMove); // ğŸ’¡ã€è¿½åŠ ã€‘Undoã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼

        // ã‚²ãƒ¼ãƒ é–‹å§‹
        initializeGame();
    </script>
</body>
</html>